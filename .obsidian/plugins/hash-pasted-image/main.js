/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HashPastedImagePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/utils.ts
var crypto = __toESM(require("crypto"));

// src/settings.ts
var DEFAULT_SETTINGS = {
  hashAlgorithm: "sha512" /* SHA512 */,
  copyImageFileSupport: false,
  notification: true
};

// src/utils.ts
var hash = (algorithm, contents) => crypto.createHash(algorithm).update(contents).digest("hex");
var path = {
  join(...partSegments) {
    let parts = [];
    for (let i = 0, l = partSegments.length; i < l; i++) {
      parts = parts.concat(partSegments[i].split("/"));
    }
    const newParts = [];
    for (let i = 0, l = parts.length; i < l; i++) {
      const part = parts[i];
      if (!part || part === ".") continue;
      else newParts.push(part);
    }
    if (parts[0] === "") newParts.unshift("");
    return newParts.join("/");
  },
  basename(fullpath) {
    const sp = fullpath.split("/");
    return sp[sp.length - 1];
  },
  extension(fullpath) {
    const positions = [...fullpath.matchAll(/\./gi)].map((a) => a.index);
    return fullpath.slice(positions[positions.length - 1] + 1);
  }
};
var stringToHashAlgorithm = (str) => {
  switch (str) {
    case "sha256":
      return "sha256" /* SHA256 */;
    case "sha384":
      return "sha384" /* SHA384 */;
    case "sha512":
      return "sha512" /* SHA512 */;
    case "md5":
      return "md5" /* MD5 */;
    default:
      return "sha512" /* SHA512 */;
  }
};

// src/main.ts
var PASTED_IMAGE_PREFIX = "Pasted image ";
var HashPastedImagePlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (!(file instanceof import_obsidian.TFile)) return;
        const timeGapMs = (/* @__PURE__ */ new Date()).getTime() - file.stat.ctime;
        if (timeGapMs > 1e3) return;
        if (isMarkdownFile(file)) return;
        let isImageFileSupport = this.settings.copyImageFileSupport && isImageFile(file);
        let isPasted = isPastedImage(file);
        if (isImageFileSupport || isPasted) {
          this.startRenameProcess(file);
        }
      })
    );
    this.addSettingTab(new SettingTab(this.app, this));
  }
  async startRenameProcess(file) {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return;
    }
    const originName = file.name;
    const newName = this.generateNewName(file);
    const newPath = path.join(file.parent.path, newName);
    try {
      await this.app.fileManager.renameFile(file, newPath);
    } catch (err) {
      console.log(err);
      throw err;
    }
    const editor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!editor) {
      return;
    }
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const replacedLine = line.replace(originName, newName);
    editor.transaction({
      changes: [
        {
          from: { ...cursor, ch: 0 },
          to: { ...cursor, ch: line.length },
          text: replacedLine
        }
      ]
    });
    if (this.settings.notification) {
      new import_obsidian.Notice(`Pasted image renamed to ${newName}`);
    }
  }
  generateNewName(file) {
    return hash(this.settings.hashAlgorithm, file.name + (/* @__PURE__ */ new Date()).toString()) + "." + file.extension;
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = { ...DEFAULT_SETTINGS, ...loadedData };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var isPastedImage = (file) => {
  if (file instanceof import_obsidian.TFile) {
    if (file.name.startsWith(PASTED_IMAGE_PREFIX)) {
      return true;
    }
  }
  return false;
};
var isImageFile = (file) => {
  if (file instanceof import_obsidian.TFile) {
    const validExtensions = [
      "jpg",
      "jpeg",
      "png",
      "gif",
      "bmp",
      "tiff",
      "tif",
      "webp",
      "heif",
      "heic",
      "svg",
      "ico"
    ];
    return validExtensions.includes(file.extension.toLowerCase());
  }
  return false;
};
var isMarkdownFile = (file) => {
  if (file instanceof import_obsidian.TFile) {
    if (file.extension === "md") {
      return true;
    }
  }
  return false;
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Hash Pasted Image Settings" });
    containerEl.createEl("p", {
      text: "Auto rename pasted images added to the vault via hash algorithm SHA-512"
    });
    new import_obsidian.Setting(containerEl).setName("Hash Algorithm").setDesc("Algorithm to hash the pasted image name.").addDropdown(
      (dropdown) => dropdown.addOption("sha256" /* SHA256 */, "SHA-256").addOption("sha384" /* SHA384 */, "SHA-384").addOption("sha512" /* SHA512 */, "SHA-512").addOption("md5" /* MD5 */, "MD5").setValue(this.plugin.settings.hashAlgorithm).onChange(async (value) => {
        this.plugin.settings.hashAlgorithm = stringToHashAlgorithm(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Copy Image File Support").setDesc(
      "Turn on to rename image files (not copy from clipboard) copied to the vault. Support formats: jpg, jpeg, png, gif, bmp, tiff, tif, webp, heif, heic, svg, ico."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.copyImageFileSupport).onChange(async (value) => {
        this.plugin.settings.copyImageFileSupport = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Notification").setDesc("Show a notification when a pasted image is renamed.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.notification).onChange(async (value) => {
        this.plugin.settings.notification = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

/* nosourcemap */